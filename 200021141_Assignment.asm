.MODEL HUGE 
.STACK 100H

.DATA
MSG1 DB 0DH, 0AH, "TOTAL NUMBER OF ITEMS: $"
MSG2 DB 0DH, 0AH, "ITEM NAME: $"
MSG3 DB 0DH, 0AH, "PRICE: $"
MSG5 DB 0DH, 0AH, "SORTED OUTPUT:$"
MSG6 DB 0DH, 0AH, "OUTPUTAFTER BINARY SEARCH:$"

ITEM DB 1024 DUP (?)
PRICES DW 100 DUP (?)
ITEM_INDICE_2 DW 100 DUP (?)
MAX DW ?

.CODE
MAIN PROC  
    MOV AX, @DATA
    MOV DS, AX
    ;INITIALISATION OF REGISTERS
    XOR CX, CX
    XOR SI, SI
    XOR AX, AX 
    XOR DI, DI
    
    LEA DX, MSG1 
    MOV AH, 9
    INT 21H
    CALL INDEC   ;CALL INDEC TO STORE THE MAXIMUM INPUTS TO DECIMAL
    MOV MAX, AX
                                                   
    MOV AH, 1
    INT 21H
    MOV ITEM_INDICE_2[0], 0  ;THE FIRST INDEX BY DEFAULT IS ZERO
    
    BEGIN:
    
    LEA DX, MSG2 
    MOV AH, 9
    INT 21H
    I1:
    MOV AH, 1
    INT 21H
    MOV ITEM[DI], AL
    INC DI
    CMP AL, 0DH   ;KEEP TAKING CHARACTER INPUT UNTIL USER PRESSES CARRIAGE RETURN
    JE ITEM_INC
    JMP I1
    
    
    ITEM_INC:    ;SAVE THE INDEX AND STORE THE PRICES
    MOV BX, DI
    MOV ITEM_INDICE_2[SI+2], BX  ;STORE THE INDEX OF CARRIAGE RETURN
    LEA DX, MSG3 
    MOV AH, 9
    INT 21H
    CALL INDEC
    ;SUB SI, 2
    MOV PRICES[SI], AX  ;SAVE THE PRICES IN PRICES ARRAY
    ADD SI, 2
    INC CX
    MOV AX, MAX
    CMP AX, CX
    JE SORT
    
    JMP BEGIN   ;LOOP UNTIL THE MAXIMUM NUMBER OF INPUT IS TAKEN
    
    SORT:
    ; SORTING USING BUBBLE SORT
    XOR CX, CX
    XOR BX, BX
    XOR DI, DI
    XOR AX, AX
    XOR DX, DX
    XOR SI, SI
    ; CLEARING ALL THE REGISTERS
  
    BUBBLE:
    XOR SI,SI
    B_3:
    MOV AX, PRICES[SI]
    MOV BX, PRICES[SI+2]
    CMP AX, BX
    JG B1
    B2:
    INC DX    
    ADD SI, 2
    MOV BX, MAX
    SUB BX, 1
    CMP DX, BX
    JE B_END
    JMP B_3
    
    B1:
    PUSH PRICES[SI]
    PUSH PRICES[SI+2]
    POP PRICES[SI]
    POP PRICES[SI+2]
    PUSH ITEM_INDICE_2[SI]
    PUSH ITEM_INDICE_2[SI+2]
    POP ITEM_INDICE_2[SI]
    POP ITEM_INDICE_2[SI+2]
    JMP B2
    
    B_END:
    XOR DX, DX
    INC CX
    MOV BX, MAX
    SUB BX, 1
    CMP CX, BX
    JNE BUBBLE
    
    LEA DX, MSG5 
    MOV AH, 9
    INT 21H
    
    ; PRINT SORTED OUTPUT
    MOV CX, 0
    CALL PRINT_SORTED_OUTPUT
    
    JMP BINARY
    
    ; BINARY SEARCH
    BINARY:
    XOR CX, CX
    XOR BX, BX
    XOR DI, DI
    XOR AX, AX
    XOR DX, DX
    XOR SI, SI
    
    MOV BX, 0
    MOV DX, MAX
    DEC DX
    MOV DI, -1
    BIN_0:
    CMP BX, DX
    JG BIN_END
    BIN_1:
    MOV CX, DX
    DEC BX
    SUB CX, BX
    SAR CX, 1
    MOV AX, CX
    INC BX
    ADD AX, BX
    MOV SI, AX
    SAL SI, 1
    CMP PRICES[SI], 20
    JE EQUAL
    JG GREATER
    JL SMALLER
    EQUAL:
    MOV DI, CX
    ADD AX, 1
    MOV BX, AX
    JMP BIN_0
    GREATER:
    SUB AX, 1
    MOV DX, AX
    JMP BIN_0
    SMALLER:
    ADD AX, 1
    MOV BX, AX
    JMP BIN_0
    BIN_END:
    CMP DI, -1
    JE NO_KEY
    BIN_END_1:
    INC DI
    MOV CX, DI                             
    LEA DX, MSG6 
    MOV AH, 9
    INT 21H
    CALL PRINT_BINARY_SEARCH
    JMP TERMINATE
    NO_KEY:
    MOV SI, DX                                      
    MOV DI, SI
    JMP BIN_END_1

TERMINATE:
    MOV AH,4CH ; FUNCTION TO EXIT PROGRAM
    INT 21H
    
PRINT_SORTED_OUTPUT PROC
    MOV CX, 0
    CALL PRINT
    RET
PRINT_SORTED_OUTPUT ENDP

PRINT_BINARY_SEARCH PROC
    CALL PRINT
    RET
PRINT_BINARY_SEARCH ENDP

PRINT PROC
    
    MOV DX, MAX
    CMP CX, DX    
    JGE TERMINATE  ;TERMINATE IF MAXIMUM NUMBER OF OUTPUT IS GIVEN
    XOR SI, SI
    P1:
    LEA DX, MSG2 
    MOV AH, 9
    INT 21H
    
    XOR SI, SI
    MOV AX, CX
    SAL AX, 1    ;MULTIPLY THE INDEX BY 2 AS OUR ITEM_INDICE_2 AND PRICES ARRAYS ARE DW ARRAYS. INDEX IS GIVEN BY 0,2,4...
    ADD SI, AX
    MOV BX, ITEM_INDICE_2[SI]
    P3:
    MOV DL, ITEM[BX]
    MOV AH, 2
    INT 21H
    INC BX
    CMP DL, 0DH
    JE P2
    JMP P3
    
    P2:
    LEA DX, MSG3 
    MOV AH, 9
    INT 21H
    XOR BX, BX
    MOV AX, PRICES[SI]
    CALL OUTDEC
    INC CX
    MOV AX, MAX
    CMP AX, CX
    JNE P1
    RET
PRINT ENDP
    
INDEC PROC
    PUSH BX
    PUSH CX
    PUSH DX
    BEGIN1:
    XOR BX, BX
    XOR CX, CX
    MOV AH, 1
    INT 21H
    
    JMP REPEAT2
    REPEAT2:
    CMP AL, '0'
    JNGE NOT_DIGIT
    CMP AL, '9'
    JNLE NOT_DIGIT
    SUB AL,48
    AND AX, 00FH
    PUSH AX
    MOV AX, 10
    MUL BX
    POP BX
    ADD BX,AX
    MOV AH,1
    INT 21H
    CMP AL, 0DH
    JNE REPEAT2
    MOV AX, BX
    EXIT:
    POP DX
    POP CX
    POP BX
    RET
    NOT_DIGIT:
    MOV AH,2
    MOV DL, 0DH
    INT 21H
    MOV DL, 0AH
    INT 21H
    JMP BEGIN1
    INDEC ENDP

OUTDEC PROC
    PUSH AX ;SAVE REGISTERS
    PUSH BX
    PUSH CX
    PUSH DX

    OR AX,AX ; AX<0?
    JGE @END_IF1 ; NO, >0

    PUSH AX ;SAVE NUMBER
    MOV DL, '-'



    MOV AH, 2 ;PRINT CHAR FUNCTION
    INT 21H ;PRINT'-'
    POP AX ;GET AX BACK
    NEG AX ;AX = -AX
    @END_IF1:
    XOR CX,CX ;CX COUNTS DIGITS
    MOV BX,10D ;BX HAS DIVISOR
    @REPEAT1:
    XOR DX,DX ;PREPARE HIGH WORD OF DIVIDEND
    DIV BX ;AX = QUOTIENT, DX = REMAINDER
    PUSH DX ;SAVE REMAINDER ON STACK
    INC CX 
    OR AX, AX 
    JNE @REPEAT1 
    MOV AH,2
    @PRINT_LOOP:
    POP DX ;DIGIT IN DL
    OR DL,30H ;CONVERT TO CHARACTER
    INT 21H ;PRINT DIGIT
    LOOP @PRINT_LOOP
    ;END_FOR
    POP DX ;RESTORE REGISTERS
    POP CX
    POP BX
    POP AX
    RET
OUTDEC ENDP

END MAIN
